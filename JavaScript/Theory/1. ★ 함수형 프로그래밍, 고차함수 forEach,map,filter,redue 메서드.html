<html>
  <head>
    <meta charset="UTF-8" />
    <title>출력결과</title>
  </head>
  <body>
    <script>
      //forEach,map,filter,reduce 이 네개의 메서드는 고차함수다.
      //고차함수란 자신의 매개변수에 인자로 함수를 받거나 반환(return)하는 값이 함수인 것을 의미한다.

      //또한 예시와 같이 프로그래밍하는걸 함수형 프로그래밍이라고 한다. 자바스크립트는 함수형 프로그래밍이 가능하다.
      //자세한건 https://higher77.tistory.com/96 에서 알아볼 수 있다.

      //
      //
      //forEach
      //
      //

      //반환 값이 없다...!
      //forEach(callback, [thisArg])  []는 Optional로 선택사항이다.
      //callback(currentValue[, index[, array]])

      //forEach 함수구조 뇌피셜

      function forEach(callback, thisArg) {
        for (let i = 0; i < a.length; i++) {
          callback(a[i], i);
        }
      }

      //위의 함수는 이해를 돕기위해서 뇌피셜로 작성된 코드다. 실제 forEach가 어떻게 작동되는지는 모른다.

      //주어진 배열의 요소를 전부 돌면서 콜백함수에 첫번째 값으로 요소의값, 두번째 값으로 요소의 인덱스 값을 준다.
      //여기서는 안썼지만 세번째 값으로 주어진 배열을 넘긴다. 즉, callback(a[i], i, a)인 것이다.

      //두번째 요소인 thisArg는 this값이고 첫번째 요소인 콜백함수에 바인딩 된다. 그냥 this를 적으면 callback함수(객체)를 가르키며 함수 안의 this를 사용한다.
      //[1,2]와 같은 객체를 주면 그것이 callback의 this가 된다.
      //콜백 안에 this를 사용하지 않는다면 null, undefined를 주거나 그냥 사용하지 않으면 된다.

      //예시

      a = [10, 11, 12, 13, 14, 15];
      a.forEach(
        function (v, i, arr) {
          console.log(v, i, arr, this);
        },
        [1, 2]
      );

      //
      //
      //map
      //
      //

      //원본 배열을 하나하나 탐색하면서 요소들을 이용하여 새로운 배열을 생성한다.
      //map(callback[,thisarg]) callback(currentValue[, index[, array]])

      //map 함수구조 뇌피셜

      function map(callback, thisArg) {
        let list = [];
        for (let i = 0; i < a.length; i++) {
          list.push(callback(a[i], i));
        }
        return list;
      }

      //예시1

      a = [10, 11, 12, 13, 14, 15];
      let answer = a.map(
        function (v, i) {
          return v * v;
        },
        [1, 2]
      );

      console.log(answer);

      //예시2
      a = [10, 11, 12, 13, 14, 15];
      let answer = a.map(
        function (v, i) {
          if (v % 2 === 0) return v;
        },
        [1, 2]
      );

      console.log(answer);

      //map메서드는 원본 배열의 길이와 똑같은 길이의 배열을 반환하기 때문에 조건에 안맞는 요소는 undefined로 나온다.

      //
      //
      //filter
      //
      //

      //map과 마찬가지로 새로운 배열을 생성해서 반환(return)받음.
      //filter(callback(element[, index[, array]])[, thisArg])

      //filter 함수구조 뇌피셜

      function map(callback, thisArg) {
        let list = [];
        for (let i = 0; i < a.length; i++) {
          if (callback(a[i], i)) list.push(a[i]);
        }
        return list;
      }

      //예시

      a = [10, 11, 12, 13, 14, 15];
      let answer = a.filter(
        function (v, i) {
          return v % 2 === 0;
        },
        [1, 2]
      );

      console.log(answer);

      //map과는 다르게 callback함수에서 true를 리턴하는 요소만 새로운 배열에 담는다.
      //filter는 말그대로 원본배열에서 조건에 맞는 요소를 고르는 것이지 새로운 값을 만들어내지는 않는다.

      //
      //
      //reduce
      //
      //

      //map,filter처럼 배열을 반환하는 것이 아니라 어떠한 값을 반환합니다.

      //reduce(callback[, initialValue])
      //callback(accumulator, currentValue [, Currentindex [, array]])

      // callback 배열의 각 요소에 대해 실행할 함수. 다음 네 가지 인수를 받습니다.
      //   accumulator 누산기는 콜백의 반환값을 누적합니다. 콜백의 이전 반환값 또는, 콜백의 첫 번째 호출이면서 initialValue를 제공한 경우에는 initialValue의 값입니다.
      //   currentValue 처리할 현재 요소.
      //   currentIndex 처리할 현재 요소의 인덱스. initialValue를 제공한 경우 0, 아니면 1부터 시작합니다.
      //   array reduce()를 호출한 배열.

      // initialValue Optional
      // callback의 최초 호출에서 첫 번째 인수에 제공하는 값. 초기값을 제공하지 않으면 배열의 첫 번째 요소를 사용합니다. 빈 배열에서 초기값 없이 reduce()를 호출하면 오류가 발생합니다.

      //reduce 함수구조 뇌피셜

      function map(callback, val) {
        let result = val;
        for (let i = 0; i < a.length; i++) {
          result = callback(result, a[i]);
        }
        return list;
      }

      //예시

      a = [10, 11, 12, 13, 14, 15];
      let answer = a.reduce(function (acc, v) {
        return acc + v;
      }, 0);

      console.log(answer);
    </script>
  </body>
</html>
