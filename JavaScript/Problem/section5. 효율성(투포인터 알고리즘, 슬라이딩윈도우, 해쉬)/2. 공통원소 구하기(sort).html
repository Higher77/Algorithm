<html>
  <head>
    <meta charset="UTF-8" />
    <title>출력결과</title>
  </head>
  <body>
    <script>
      //문제. A, B 두 개의 집합이 주어지면 두 집합의 공통 원소를 추출하여 오름차순으로 출력하는 프로그램을 작성하세요.

      //첫 번째 줄에 집합 A의 크기 N(1<=N<=30,000)이 주어집니다.
      //두 번째 줄에 N개의 원소가 주어집니다. 원소가 중복되어 주어지지 않습니다.
      //세 번째 줄에 집합 B의 크기 N(1<=N<=30,000)이 주어집니다.
      //네 번째 줄에 M개의 원소가 주어집니다. 원소가 중복되어 주어지지 않습니다.
      //각 집합의 원소는 1,000,000,000이하의 자연수입니다.

      //My Answer

      function solution(arr1, arr2) {
        let answer = [];

        arr1.sort((a, b) => a - b);
        arr2.sort((a, b) => a - b);

        for (let x of arr1) {
          if (arr2.indexOf(x) !== -1) answer.push(x);
        }

        return answer;
      }

      let a = [1, 3, 10, 5, 2];
      let b = [3, 2, 5, 7, 8];
      console.log(solution(a, b));

      //이렇게하면 for=> n. indexOf=>m  n x m이여서 시간복잡도가 O(mn)이 된다.

      //
      //
      //Lecture Answer
      //
      //
      //첫번째 풀이

      function solution(arr1, arr2) {
        let answer = [];
        arr1.sort((a, b) => a - b); //[1,2,3,5,10]
        arr2.sort((a, b) => a - b); //[2,3,5,7,8]
        let p1 = (p2 = 0);
        while (p1 < arr1.length && p2 < arr2.length) {
          if (arr1[p1] == arr2[p2]) {
            answer.push(arr1[p1++]); //같은걸 찾으면 p1,p2에 ++를 해준다.
            p2++;
          }
          //p1,p2중 더 작은값을 ++해준다. 왜냐하면 오름차순으로 정렬했기 때문에 큰 값을 ++해도 일치하는 수가 나올 수 없기 때문이다.
          else if (arr1[p1] < arr2[p2]) p1++;
          else p2++;
        }
        return answer;
      }
      //sort는 배열의 원소들을 문자열로로 변환한다음에 정렬한다. 정렬 기준을 주지 않으면 문자처럼 사전순으로 정렬된다.
      //그래서 10이상의 숫자를 넣으면 [1,3,10,5,2] => [1,10,2,3,5]순으로 정렬한다. 그렇기 때문에
      //sort((a,b) => a-b)로 오름차순 정렬이라고 정해줘야 한다.
    </script>
  </body>
</html>
