<html>
  <head>
    <meta charset="UTF-8" />
    <title>출력결과</title>
  </head>
  <body>
    <script>
      //문제.
      //자연수 N을 입력하면 N!값을 구하세요. N! = n*(n-1)*(n-2)*.....*2*1입니다. 만약 N=5라면 5!=5*4*3*2*1=120입니다.

      //첫째 줄에 자연수 N(3<=n<=10)이 입력됩니다.

      //첫째 줄에 N팩토리얼 값을 출력합니다.

      //Lecture Answer
      //
      //
      //첫번째 풀이

      function solution(n, r) {
        let answer = [];
        ////다음과 같은 방법으로 2차원배열을 만들 수 있다. 첫번쨰가 행(가로)이고 두번째가 열(세로)이다
        let dy = Array.from(Array(35), () => Array(35).fill(0));

        function DFS(n, r) {
          if (dy[n][r] > 0) return dy[n][r];
          if (n === r || r === 0) return 1;
          //3C3, 3C0은 1이다.
          else return (dy[n][r] = DFS(n - 1, r - 1) + DFS(n - 1, r)); // return b=10을 하면 b에 10이 저장되고 리턴값은 10이 나온다.
        }
        answer = DFS(n, r);
        return answer;
      }

      console.log(solution(5, 3));

      //5C3 = 4C2 + 4C3이다.
      //{1,2,3,4,5}가 있다고 할 때 5의 입장에서 생각해보면 5C3은
      //5가 포함되지 않고 남은 4개중 3개를 뽑는것 + 5가 포함되어서 남은 4개중 2개를 뽑는 것이다.
      //즉, 4C3 + 4C2인 것이다.

      //D(3,2) = D(2,1) + D(2,2)이고
      //D(3,1) = D(2,0) + D(2,1)이다.

      //여기서 D(2,1)이 겹치는데 이미 구한 D(2,1)값을 다시 루트를 뻗어서 번거롭게 계산을 복잡하게 하지않고 어딘가에 기록해두면
      //계산이 간단해질 수 있다. 이런걸 '메모이제이션'이라고 한다.

      //dy변수에 2차원배열을 만들어 dy[n][r] = DFS(n,r)값을 기록해두면 나중에 중복되는 값이 나올 경우 쉽게 꺼내 쓸 수 있다.
    </script>
  </body>
</html>
